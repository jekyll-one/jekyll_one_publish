---
title:                                  J1 Webhooks
tagline:                                managing webhooks at github
description:                            Managing Github Webhooks

tags:                                   [ App, Git, Github ]
index:                                  [ Git, Github, Webhooks, Hooks, NPM, Pull, Built, Build, Server, Utility ]
categories:                             [ pages ]

permalink:                              /pages/public/j1_webhooks/
regenerate:                             false

resources:                              [ lightbox ]
resource_options:
  - attic:
      padding_top:                      400
      padding_bottom:                   50
      opacity:                          0.5
      slides:
        - url:                          /assets/images/attics/antonella-lombardi-1920x1280.jpg
          alt:                          Photo by Antonella Lombardi on Unsplash
          badge:
            type:                       unsplash
            author:                     Antonella Lombardi
            href:                       https://unsplash.com/@missd
---

// Enable the Liquid Preprocessor
// -----------------------------------------------------------------------------
:page-liquid:

// Set other global page attributes here
// -----------------------------------------------------------------------------
//:my-asciidoc-attribute:

//  Load Liquid procedures
// -----------------------------------------------------------------------------
{% capture set_env_entry_document %}themes/{{site.template.name}}/procedures/global/set_env_entry_document.proc{%endcapture%}


// Initialize entry document environmental attributes
// -----------------------------------------------------------------------------
{% include {{set_env_entry_document}} %}

// Load tag, url and data attributes
// -----------------------------------------------------------------------------
include::{includedir}/attributes.asciidoc[tag=tags]
include::{includedir}/attributes.asciidoc[tag=urls]
include::{includedir}/attributes.asciidoc[tag=data]

// Set local page attributes
// -----------------------------------------------------------------------------
// :images-dir:                         {imagesdir}/path/to/page/images


// Page content
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Include sub-documents
// -----------------------------------------------------------------------------

GitHub is a Git repository *hosting service* on the Internet for personal and
professional use. GitHub adds many features on such hosted Git repositories to 
make the work more productive. 

While Git is a command line tool, GitHub provides a web-based graphical 
interface and also provides for every project:

* access control and sharing features known as *forking* and *pulling*
* collaboration features (organisations)
* basic task and project management tools
* web hosting services for project-related websites
* integration features like Webhooks and OAuth authentication


[NOTE]
====
*Forking* at Github is copying a repository from one user’s account to 
another. This enables you to take a project that you don’t have write 
access to and modify it under your own account. 

If you make changes you’d like to share, you can send a notification 
called a *pull request* to the original owner. That user can then, 
with a click of a button, merge the changes found in your repo with 
the original repo and check the changes proposed.
====

This article is focussing on *integration features* of J1 Template for Github
using *Webhooks*. Webhooks allow you to build integrations with your 
repositories by subscribing to certain *events*. When one of those events is 
being triggered, the hosting server at GitHub send a *HTTP POST* payload to 
an configurable URL. A really great feature!

In short: Webhooks implement event driven information services to provide 
certain data (the payload) to your systems to act on. You're only limited by 
your imagination what can be done. One example on how Webhooks can be used is
already integrated with J1 Template!

Curious to see what that could be?

== GH Webhook integration

Github Webhooks can be used to update external services like issue trackers, 
can be used to trigger link:{wikipedia-en-ci}[CI builds, {window}] on e.g. 
professional platforms like link:{travis-ci-home}[Travis CI, {window}]. Or 
even deploy and process changes of your repo to your production server and 
to your *local* working copy of a GH repo using J1 Template as well.

Unbelievable? No, it's real.

=== J1 Webhook Flow

First of all, it seems *not* possible to receive data send by a Webhook on a 
system using a local, a *private* IP address like *localhost* (127.0.0.1). 
A Webhook URL configured at Github has to be a *public* address reachable on 
the Internet. Private IP's are never exposed on the Internet. They are 
*private* is in best sense: not reachable from the outer world.

This makes private IP addresses intrinsically secure. You're really safe but
you are limited in terms of communication to your *local world*. For that
reason, a additional system is needed that acts somewhere in the *middle* of
the communication channel to *receive* the data *on behalf*.

The character of the communication channel for Webhooks could be described as 
a one-way-ticket. The public URL to be configured at Github allows a 
*subscriber* to receive data, but never sending something back. So, this 
raises the question, how a localized system can subscribe to a communication 
channel in the public?

Have a look at the flow diagram below to give the answer.

.J1 Webhook Flow
lightbox::webhook-flow-2[800, {data-j1-webhook-flow}]

The solution is to implement a middleare system on the Internet that receives 
what is send by GH Webhooks *on behalf*. A *free* Webhook payload delivery 
service is provided by the link:{gh-probot-team}[Probot team, {window}] 
at link:{seeme-io-home}[SeeMe, {window}]. For sure, a really great application 
hosted at link:{heroku-home}[Heroku, {window}] to make this possible.

NOTE: Smee.io is intended for use in *development* environments, not for 
*production*. It's a way to inspect payloads through a UI and receive them on 
a local machine, not as a proxy for production applications. For productive 
systems,  a middleware like SeeMe is *not* needed as those applications should
manage Webhooks on their own.

The *event* registered at Github for a Webhook used with J1 Template is a 
*push* event. If a repo at Github gets updated by a commandline git *push* 
command, the Webhook is triggered to send the data (payload) a as JSON string 
to the SeeMe middleware.

J1 Template has implemented a (Javascript based) monitor component to listen
on messages available at SeeMe, previously send by Github as a Webhook payload. 

This monitor is build on two subsystems:

* Server-Sent-Events extention (SSE) of modern web browsers
* Github API (Octokit client)

[NOTE]
====
Developing a web (application) service that uses server-sent-events 
(SSE) is much easier rather than using e.g. a full-duplex protocol stack like 
link:{wikipedia-websocket}[Websockets]. If a server already support stream 
data on events, the client sided browser code (Javascript) works 
almost identically to handle SSE events like any other events registered. 
Like button-click events for example.

The extention link:{mdn-server-sent-events}[Server-Sent-Events, {window}] is 
an built-in API available with almost all modern web browsers, except 
Microsoft browsers like *IE* or *Edge*.
====

The Server-Sent-Events API provides a very simple interface *EventSource* 
to register on events from a server like SeeMe. EventSource is an abstraction
layer to implement a event handler (monitor) on server-sided channels quite
the same as any other event that is registered with Javascript-based code in 
a web page.

For now, see the SSE monitor as a Javascript component listening on events but
emitted by a *remote* source (URL) rather than *local* events like mouse 
clicks on hyperlinks or buttons.

The interface *EventSource* enables a browser application to listen on remote
servers. That's great. But to *understand* what a server has send over the 
(communication) channel, a client API is needed for security reason and to
transform the data stream received into a Javascript representation for 
further processing.

Have again a look at the flow:

. a git push command triggers an (Webhook) event at GH
. the public address registered at Github is the middleware SeeMe (URL)
. the webhook emit a data message (payload) send to SeeMe
. the middleware SeeMe store the message and forward the paylod on an
  SSE request

Yes, folks a lot of theory; for sure. 

It's time to make processing Webhooks real. With the following, a base 
configuration is done am Github, SeeMe and your awesome website to see this 
in action.


== Preparations using Webhooks

It is expected that you have an account at Github already and a development
environment for J1 Template in place that includes a current version of *Git*, 
*Ruby* and *NodeJS*.

TIP: If you havent't worked with J1 Template, it's recommended to go for 
the Kickstarter link:{kickstart-web-in-a-day}[Web in a day] first to learn
what is J1 all about.

=== Create a site

As you know, is not a big deal to setup a new website using J1. Go for your
development folder e.g. ~/j1/my_webs and create a new site:

[source, bash]
----
j1 generate webhooks
----

On a windows system, you'll see something like this:

.J1 site generation
----
Running bundle install in C:/j1/my_webs/webhooks ...
           Bundler: Fetching gem metadata from https://rubygems.org/..........
           Bundler: Fetching gem metadata from https://rubygems.org/.
           Bundler: Resolving dependencies......
           Bundler: Using rake 12.3.3
           Bundler: Using concurrent-ruby 1.1.5
...
...
           Bundler: Using wdm 0.1.1
           Bundler: Bundle complete! 23 Gemfile dependencies, 92 gems now installed.
           Bundler: Use `bundle info [gemname]` to see where a bundled gem is installed.
Generated Jekyll site installed in folder C:/j1/my_webs/webhooks
----

Setup and run the new site:

[source, bash]
----
cd webhooks && yarn setup && yarn site
----

.J1 site setup
----
Setup project for first use ..
Bootstrap base modules ..
done.
Configure environment ..
...
...
Startup the site ..
Startup utility server ..
Configuration file: C:/j1/my_webs/webhooks/_config.yml
Startup utility server globally disabled, not started.
            Source: .
       Destination: _site
 Incremental build: enabled
      Generating...
         AutoPages: Disabled/Not configured in site.config.
        Pagination: Complete, processed 1 pagination page(s)
                    done in 55.027 seconds.
 Auto-regeneration: enabled for '.'
LiveReload address: http://localhost:35729
    Server address: http://localhost:4000/
  Server running... press ctrl-c to stop.
----

As the setup process for the site is finished, the builder engine *Jekyll* is 
called and a web browser is run to display the new website. Check some pages, 
open the developer console of your web browser and check the logs to make sure 
that all went fine sofar.

From the screen shot, you see filtered logs from a page view selecting only
*finished* messages (using a chromium based browser like Google Chrome). The
Github API *Octokit* is enabled by default. That means Webhooks can be used out
of the box if configured properly.

.Browser Console (Chrome)
lightbox::browser-console-new-site[800, {data-browser-console-new-site}]


=== Create a GH repo

To continue on Github, signin your account and link:{gh-new-repo}[create a new repo]. 
In this example, the repo is named *webhooks*. Setup a local Git working copy 
to be uploaded to Github as the remote.

In the project folder, two files:

* dot.gitignore
* dot.gitattributes

are prepared for proper Git settings at GH. Rename the files to their 
original file names:

* .gitignore
* .gitattributes

and create a local working copy of the newly created site.

.Create a local working copy
[source, bash]
----
git init && git add . && git commit -am "Initial commit"
----

.messages from git commands
----
Initialized empty Git repository in C:/j1/my_webs/webhooks/.git/
[master (root-commit) ab34279] Initial commit
 912 files changed, 395729 insertions(+)
 create mode 100644 .gitattributes
 create mode 100644 .gitignore
 create mode 100644 Gemfile
 create mode 100644 _cc_test_data/_config.yml
 create mode 100644 _cc_test_data/_data/apps/j1_bootstrap_gallery.yml
 create mode 100644 _cc_test_data/_data/apps/j1_carousel.yml
...
...
 create mode 100644 utilsrv/_tools/windows/util_server.xml
 create mode 100644 utilsrv/package.json
 create mode 100644 utilsrv/server.js
----

Upload your files to the Github repo created ealier. Please note that you 
need to adjust the Github repo URL for your needs.

.Upload the local working copy
[source, bash]
----
git remote add origin https://github.com/<your-account>/webhooks.git
git push -u origin master
----

.Upload messages from GitHub
----
Enumerating objects: 1114, done.
Counting objects: 100% (1114/1114), done.
Delta compression using up to 4 threads.
Compressing objects: 100% (1044/1044), done.
Writing objects: 100% (1114/1114), 59.75 MiB | 547.00 KiB/s, done.
Total 1114 (delta 235), reused 0 (delta 0)
remote: Resolving deltas: 100% (235/235), done.
To https://github.com/jekyll-one-org/webhooks.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.
----

To not modify the base setup for your new site with the master branch, it 
makes sense to create and checkout a new branch:

.Create a new branch to work on Webhooks
[source, bash]
----
git checkout -b webhooks
----

.New branch _webhooks_to continue the setup
----
Switched to a new branch 'webhooks'
----

For now, that's all for the new repo at Github. The next step is to configure
the middleware *SeeMe* as the receiver for data messages send on Webhook events
and on the other hand the server system to be monitored by your website using
SSE.

=== Setting up SeeMe

It's really easy to create an SeeMe instance, a new channel. Point your 
browser to  this link:{seeme-io-new-channel}[link at smee.io, {window}] 
and you're done!

What's needed to *finish* the configuration at Github for setting up a Webhook
for your repo is the URL of the channel created:

.New channel (Webhook Proxy URL) at smee.io
lightbox::smee-new-channel[800, {data-smee-new-channel}]

The new channel is identified by the *Webhook Proxy URL*; that's all.


=== Setup the Webhook at GH

To continue the setup at GH, go back to the GH Web interface to manage your
repo *settings*. On the left of the repo settings page, you find a link called 
*Webhooks* to configure events.

.Repo settings page at Github
lightbox::gh-repo-settings[800, {data-gh-repo-settings}]

Continue to configure the Webhook event for a *git push* event by clicking on
the link *Webhooks*. On the page opened next, you find on the top right a 
button *Add webhook* that points you to the configuration page to setup the 
Webhook details.

.Configuration page to configure a Webhook at Github
lightbox::gh-webhook-settings[800, {data-gh-webhook-settings}]

To add the Webhook, the parameters:

* Payload URL (*Webhook Proxy URL* from SeeMe)
* Content type: *application/json*
* an application *secret*

are required.

[TIP]
====
For the application secret, e.g. a 128-bit Hex key like 

  15cb12a58a04d326567e4b60acafc634

can be used. Keep the application secret in a safe place and *never* publish
this key on the public (a repo at GH for example) as the secret ensures your
data cannot be read by others. 
====

All other settings can be left in their defaults:

* SSL settings
* Event settings (push event is the default)

As you click on the button *Add webhook*, the hook gets activated and instantly 
a ping (test payload) is send out to the payload URL for verification. On the
web page of your SeeMe channel, this ping should be received and could be 
checked.

.Result page (initial) for a webhook configured at Github
lightbox::gh-webhook-settings-post[800, {data-gh-webhook-settings-post}]

Open the *Webhook Proxy URL* at SeeMe and the *Delivery page* is presented
to check what a (Webhook) payload was send by GH respectively received at 
SeeMe.

.Delivery page at SeeMe the ping from GH was received
lightbox::smee-ping-reveived[800, {data-smee-ping-reveived}]

At this stage, all remote infrastructure components are being setup. Your new
website has a nice home at Github in a repo connected by a Webhook that emits
data messages over the Payload URL to your middleware system on *push* events.
And the middleware, the SeeMe channel, is manageable over the *Webhook Proxy URL*.

Great stuff, isn't it!?

Again, have a look at the flow implemeted with J1 for GH Webhooks:

.J1 Webhook Flow
lightbox::webhook-flow-1[800, {data-j1-webhook-flow}]

As you can see from the flow, the next component to be configured is the
*middleare monitor* based on Githubs *Octokit* client API and a *SSE event 
handler* to retrieve and process the payload send by Github (over SeeMe).

== J1 WebHooks

J1 WebHooks is a so-called J1 Template *module*, a component ready to use. No 
need to do any Javascript programming stuff here. Many J1 modules can be used
out of the box, other needs some configuration settings to make the module 
*individual*. J1 WebHooks is a module that needs some settings - imagine the 
*Webhook Proxy URL* that is generated by SeeMe for needs.

As every module in the J1 world, modules are managed as so-called *resources*. 
A resource is a set of web page sources, like JS and and CSS files, accompanied
by a set of configuration parameters to specify where files are located and how
they should be processed by the browser.

All resources used for a website are defined in a single YAML config file:
*resources.yml*. This file is located under the folder *_data/* in the project
root directory (in this example ~/j1/my_webs/webhooks/_data).

The resource settings for J1 WebHooks are:

.Resource record of the J1 WebHooks module
[source, yml]
----
  # ----------------------------------------------------------------------------
  # WebHooks
  #
  - name:                               J1 WebHooks
    resource:
      id:                               webhooks
      enabled:                          true
      comment:                          module webhooks
      region:                           head
      layout:                           [ all ]
      required:                         always
      script_load:                      sync
      dependencies:                     [ logger ]
      pass_init_data:                   false
      data:
        css:                            []
        files:                          [ adapter/js/webhooks.js ]
        js:                             []
        init_function:                  [ j1.adapter.webhooks.init ]
----

The module Webhooks is *enabled* by default, loaded for all layouts of a web
sychrounously at the time a page is requested by a web browser. From the
prospective of a web, J1 modules are Javascript clients providing dynamic 
features to a website - to all or to specific pages. 

To bring such a client alive, to be used on a page an *adapter* is used to 
interface, to initialize all resources needed, to make them usable. From the 
resource record of J1 Webhooks it *seems* that no other resource is used to 
add Github Webhooks to a web rather than *webhooks.js*. As mentioned ealier, 
to use GH Webhooks, the Octokit client API is needed.

The Octokit client API is part of the main Javascript core of J1 Template:
*template.js*. The core JS is loaded for each and every web page automatically.
Because the JS core is already loaded and available for all pages of a site,
the core resource is *not* needed to be specified on a module level.

To get an oveview what happens seen from a web browser, check the source code 
of the home page for the J1 Webhook module.

.HTML code to load an run the Webhook module
[source, yml]
----
<1>
<!-- [INFO   ] [j1.layout.resource_writer.proc        ] [ layout: all template core ] -->
<!-- [INFO   ] [j1.layout.resource_writer.proc        ] [ layout all, place js files for resource ID: core ] -->
<script sync src="/assets/themes/j1/core/js/template.js"></script>
<2>
<!-- [INFO   ] [j1.layout_resource_generator.html     ] [ process resource: webhook ] -->
<!-- [INFO   ] [j1.layout.resource_writer.proc        ] [ layout: all, module webhooks ] -->
<!-- [INFO   ] [j1.layout.resource_writer.proc        ] [ layout: all, place general file resources for resource_settings.id: webhook ] -->
<script sync src="/assets/themes/j1/adapter/js/octokit.js"></script>
...
<3>
<!-- [INFO   ] [j1.layout_shim_generator.html         ] [ place container for WebHook Modals ] --> 
<div id="web_hook_modals"></div>
...
<4>
<!-- [INFO   ] [j1.layout_module_generator.html       ] [ process resource: webhook ] -->
<!-- [INFO   ] [j1.layout.module_writer.proc          ] [ dependencies detected: ["logger"] ] -->
<!-- [INFO   ] [j1.layout.module_writer.proc          ] [ place J1 adapter for resource: webhook ] -->
<script>
  $(document).ready(function() {
    var logger = log4javascript.getLogger("j1.module_loader");
    var log_text = 'module webhooks is being initialized';
    logger.info(log_text);
    // [INFO   ] [j1.layout.module_writer.proc          ] [ pass init data for: webhook ]
    var settings = $.extend({}, {"layout": "home", "scrollbar": "false", "toc": "false", "comments": "false"});
      // Initialize module if resource_settings.dependencies reached state 'finished'
      var interval_count = 0;
      var max_count      = 10;
      var dependencies_met_webhook = setInterval(function() {
        interval_count += 1;
        if ( j1.adapter.logger.getState() == 'finished' ) {
          j1.adapter.octokit.init(settings);
          logger.info('dependencies of module webhook met for: logger');
          logger.debug('dependencies of module webhook met after: ' + interval_count * 25 + ' ms');
          clearInterval(dependencies_met_webhook);
          }
        if (interval_count > max_count) {
          logger.warn('dependency check failed for module: webhook');
          clearInterval(dependencies_met_webhook);
          logger.warn('run initializer webhook unchecked for: logger');
          j1.adapter.octokit.init(settings);
        }
      }, 25);
  });
</script>
----
<1> module loader to place the core JS
<2> module loader to place the Webhooks module resources
<3> interface loader to add a placeholder container
<4> module generator to place the JS initialzer for the Webhooks module

You'll find three code sequences specifically for the Webhooks 
module:

. the JS script definition written by the J1 module loader
. a placeholder (<div>) container written by the J1 interface loader
. a JS initialzer to fireup and initialize the module written by the J1 generator

The J1 module loader place a <script> definition in the HTML <head> section of
all pages to initiate the browser to load this resource as an Javascript file. 
This is done for all modules having JS files to load. 

The placeholder (<div>) container is used for UI components (Bootstrap Modals)
to interact and control the module if an event is received. Those containers
are placed only for modules that are providing a *user interface*. In other 
words: this module provides an user interface. That's the message here.

And lastly the J1 module generator place a JS initializer to be fire up and 
initializes the module on an *page ready* event emitted by the browser. Again, 
not very special as all modules using JS scripts under the hood are initialized
that way.

=== Module configuration

Module settings are located in the folder *_data/* under the directory 
*modules*. For this example the path is: 

  ~/j1/my_webs/webhooks/_data/modules

Module configuration settings are YAML files, typically used for a Jekyll based
static website.

.J1 WebHooks YAML configuration _webhooks.yml_
[source, yml]
----
# ------------------------------------------------------------------------------
# User configuration settings
#
settings:
  enabled:                              true                                    

  # Webhook secret from GH
  secret:                               12ada70c0d34XXXXXX1a790c9b23bd
  # Webhook payload URL from SeeMe
  payload_url:                          https://smee.io/IUhXXXXdy7G335

  # Webhooks client UI (BS Modals)
  # ----------------------------------------------------------------------------
  commit_detection:

    modal_commit_detected:
      enabled:                          true
      autohide:                         false
      autohidden:                       5000

    modal_pull_response:
      enabled:                          false
      autohide:                         false
      autohidden:                       5000
----



.Redeliver a payload from a previous Webhook event at Github
lightbox::gh-redeliver-wh-payload[800, {data-gh-redeliver-wh-payload}]

.Receive a payload from a previous Webhook event
lightbox::receive-redelivered-payload[800, {data-receive-redelivered-payload}]










